# 20377199 赵芮箐 第13周作业

![image-20221129001940437](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20221129001940437.png)

### 题目二思路：

- 服务端的主线程用tcp一直监听，客户端进行接入
- 获取客户端的ip和端口后，开启子线程用udp传输监控视频数据
- 客户端退出时会通过udp反馈信息，子线程随即结束

> maybe tcp&udp一起用的写法有点笨蛋，但是是改了多次后妥协的结果。
>
> 只用udp实现全部的话，客户端退出后主线程的网络也会断掉，其他的客户端就没办法接入了。
>
> 所以最后选择用tcp实现接入确认的这部分，不得不说tcp三次握手is可靠许多。
>
> anyway, 至少是tcp和udp都练习到了就是说。

### Part1: 服务端

```python
import cv2
import sys
import numpy as np
from socket import *
from threading import Thread
from datetime import datetime

class Server():
    def __init__(self, socket, addr, capture):
        self._socket = socket
        self._addr = addr
        self._cap = capture
    
    def __get_cam(self):
        while True:
            ret, frame = self._cap.read()
            yield frame

    def post_cam(self):
        for frame in self.__get_cam():
            img_encode = cv2.imencode('.jpg', frame)[1]
            data_encode = np.array(img_encode)
            data = data_encode.tobytes()
            self._socket.sendto(data, self._addr)
            reply, addr = self._socket.recvfrom(1024)
            # 收到客户端消息若为退出, 则结束线程
            if reply.decode('utf-8') == 'end':
                break
        with open('week13/ServerLog.txt', 'a', encoding='utf-8') as f:
            f.write(f'{datetime.now()} 客户端{self._addr} 退出\n')

def accpet_client():
    # tcp通讯用于获取接入的ip
    tcp_socket = socket(AF_INET, SOCK_STREAM)
    tcp_socket.bind(('0.0.0.0', 9999))
    tcp_socket.listen(5)
    # udp通讯用于传输视频
    udp_socket = socket(AF_INET, SOCK_DGRAM)
    capture = cv2.VideoCapture(0)
    capture.set(3, 160) # 故意修改小的，不然mac上容易超过udp发送数据的长度限制
    capture.set(4, 90)  # windows上好像不用这么小
    while True:
        print('新的客户端正在接入中...')
        conn, addr = tcp_socket.accept()
        client = (addr[0], int(conn.recv(1024).decode('utf-8')))
        # 记录Log日志
        with open('week13/ServerLog.txt', 'a', encoding='utf-8') as f:
            f.write(f'{datetime.now()} 客户端{client} 接入\n')
        # 开启子线程, 传输监控视频
        s = Server(udp_socket, client, capture)
        t = Thread(target=Server.post_cam, args=(s,))
        t.start()

if __name__ == "__main__":
    a = Thread(target=accpet_client)
    a.start()
    a.join()
```

### Part2: 客户端

```python
import cv2
import sys
import time
import numpy as np
from socket import *
from datetime import datetime

rsize = 400000
fourcc = cv2.VideoWriter_fourcc(*'XVID')

class Receiver:
    def __init__(self, socket, addr, savetime=15, savepath='D:/code/mp2022/week13/camera'):
        self._socket = socket
        self._addr = addr
        self._time = savetime
        self._path = savepath
    
    def __save_cam(self, frame):
        # 每一段时间储存一次视频
        if time.time() - self._start > self._time:
            self._start = time.time()
            path = self._path + (datetime.now().strftime('%H-%M-%S')) + '.avi'
            self._out = cv2.VideoWriter(path, fourcc, 10.0, (160,120))
        self._out.write(frame)

    def receive_cam(self):
        self._socket.bind(self._addr)
        self._start = time.time()
        path = self._path + (datetime.now().strftime('%H-%M-%S')) + '.avi'
        self._out = cv2.VideoWriter(path, fourcc, 10.0, (160,120))
        # fourcc 指定编码器; fps 要保存的视频的帧率
        while True:
            data, addr = self._socket.recvfrom(rsize)
            nparr = np.frombuffer(data, np.uint8)
            img_decode = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            cv2.imshow('receive', img_decode)
            self.__save_cam(img_decode)		# 储存每一帧
            c = cv2.waitKey(50)
            udp_socket.sendto('continue'.encode('utf-8'), addr)
            if c == 27:         			# 按了esc后可以退出
                cv2.destroyAllWindows()
                udp_socket.sendto('end'.encode('utf-8'), addr)
                break

if __name__ == "__main__":
    # 和服务器连接, 将自己ip和port发过去
    # sys.argv[1], sys.argv[2] 是服务器的ip和port
    # sys.argv[3] 是客户端用于接收视频的端口号
    tcp_socket = socket(AF_INET, SOCK_STREAM)
    tcp_socket.connect((sys.argv[1], int(sys.argv[2])))
    tcp_socket.send((sys.argv[3]).encode('utf-8'))
    udp_socket = socket(AF_INET, SOCK_DGRAM)
    r = Receiver(udp_socket, ('0.0.0.0', int(sys.argv[3])))
    r.receive_cam()
```

### 测试结果：

- 多台客户端链接获取视频：

  <img src="C:\Users\DELL\AppData\Local\Temp\WeChat Files\927b42d0108753d43dde969d46d76ab.jpg" alt="927b42d0108753d43dde969d46d76ab" style="zoom:33%;" />

  <img src="C:\Users\DELL\AppData\Local\Temp\WeChat Files\2d3a956e4b071ed7b39165debec9011.jpg" alt="2d3a956e4b071ed7b39165debec9011" style="zoom:34%;" />

  <img src="C:\Users\DELL\AppData\Local\Temp\WeChat Files\a2514e14f145d83fdce90cce939e04f.jpg" alt="a2514e14f145d83fdce90cce939e04f" style="zoom:31.5%;" />

- 保存的视频：

  <img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20221205000849390.png" alt="image-20221205000849390" style="zoom:50%;" />

  > 可爱而又模糊的我

- Log日志：

  <img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20221204232534455.png" alt="image-20221204232534455" style="zoom:50%;" />

  > 可以多台客户端同时接入，退出去之后也可以再进来

### 代码：

https://github.com/rachhhhing/mp2022_python/blob/master/week13

### Ref:

- UDP通信：https://blog.csdn.net/qq_19446965/article/details/110678592
- opencv：https://zhuanlan.zhihu.com/p/44255577

**最后，本周作业特别鸣谢 ljx 和 jzk 同学，在一起分装物资的晚上专门带电脑出门帮我测试**

**特别批评 dxl 同学，明明也要来却以电脑太重为由拒绝了我😡**
